<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pin: Fast Buffering APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Pin</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Fast Buffering APIs</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VOID *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#ga2f5cb32e7787a78f3d82777ccc6bcc74">LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK</a> )(BUFFER_ID id, <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElements, VOID *v)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BUFFER_ID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#ga008bd698d07658fc4f60fd9b61fb81bc">LEVEL_PINCLIENT::PIN_DefineTraceBuffer</a> (size_t recordSize, UINT32 numPages, TRACE_BUFFER_CALLBACK fun, VOID *val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#ga2c9c14f8b8dc4a6cb6c137f533d8d14a">LEVEL_PINCLIENT::PIN_AllocateBuffer</a> (BUFFER_ID id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#gad6f219bd78622a73d42d37e3f9d6801e">LEVEL_PINCLIENT::PIN_DeallocateBuffer</a> (BUFFER_ID id, VOID *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#ga2c67a48c18fcdc9c88ed826e28f40434">LEVEL_PINCLIENT::PIN_GetBufferPointer</a> (<a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *const ctxt, BUFFER_ID id)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>APIs to perform low-overhead buffering of data for analysis. Use <a class="el" href="group__BUFFER__API.html#ga008bd698d07658fc4f60fd9b61fb81bc">PIN_DefineTraceBuffer()</a> to create space for storing data, and <a class="el" href="group__INS__INST__API.html#gacf731514b88f79344068df5d8e60eacc">INS_InsertFillBuffer()</a> to fill the buffers. When a buffer overflows, or the thread exits, the defined callback will be used to process the data.</p>
<p>APIs to perform low-overhead buffering of data for analysis. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga2f5cb32e7787a78f3d82777ccc6bcc74"></a><!-- doxytag: member="LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK" ref="ga2f5cb32e7787a78f3d82777ccc6bcc74" args=")(BUFFER_ID id, THREADID tid, const CONTEXT *ctxt, VOID *buf, UINT64 numElements, VOID *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID*(* <a class="el" href="group__BUFFER__API.html#ga2f5cb32e7787a78f3d82777ccc6bcc74">LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK</a>)(BUFFER_ID id, <a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElements, VOID *v)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A call-back function which Pin calls whenever the tools needs to consume a trace buffer (e.g., the trace buffer is full).</p>
<p>This function may be called on a different thread than the given threadIndex.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The ID of the trace buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The ID of the thread owning this buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to the start of the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements collected into the buffer which need to be consumed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The tool's call-back value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the buffer to use when the thread resumes. Typically, this is <em>buf</em>, but see also <a class="el" href="group__BUFFER__API.html#ga2c9c14f8b8dc4a6cb6c137f533d8d14a">PIN_AllocateBuffer()</a>. </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga2c9c14f8b8dc4a6cb6c137f533d8d14a"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AllocateBuffer" ref="ga2c9c14f8b8dc4a6cb6c137f533d8d14a" args="(BUFFER_ID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* LEVEL_PINCLIENT::PIN_AllocateBuffer </td>
          <td>(</td>
          <td class="paramtype">BUFFER_ID&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Explicitly allocate a trace buffer. This is only needed for tools which use a "double buffering" technique. When used, the buffer pointer should be returned from the TRACE_BUFFER_CALLBACK call-back.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The ID of the trace buffer to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the new buffer.]</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux &amp; Windows<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gad6f219bd78622a73d42d37e3f9d6801e"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_DeallocateBuffer" ref="gad6f219bd78622a73d42d37e3f9d6801e" args="(BUFFER_ID id, VOID *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_DeallocateBuffer </td>
          <td>(</td>
          <td class="paramtype">BUFFER_ID&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Explicitly deallocate a trace buffer. This is only needed by tools using a "double buffering" technique, where it is used to deallocate buffers allocated via <a class="el" href="group__BUFFER__API.html#ga2c9c14f8b8dc4a6cb6c137f533d8d14a">PIN_AllocateBuffer()</a>. However, it may be safely called (with no effect) for a thread's implicit initial buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The ID of the trace buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to the start of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux &amp; Windows<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga008bd698d07658fc4f60fd9b61fb81bc"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_DefineTraceBuffer" ref="ga008bd698d07658fc4f60fd9b61fb81bc" args="(size_t recordSize, UINT32 numPages, TRACE_BUFFER_CALLBACK fun, VOID *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BUFFER_ID LEVEL_PINCLIENT::PIN_DefineTraceBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>recordSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>numPages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRACE_BUFFER_CALLBACK&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define a trace buffer to use with the Pin trace buffer API. This function defines the shape of the buffer, but doesn't allocate the buffer itself. Each thread implicitly creates its first buffer on start-up. Additional buffers may then be created using <a class="el" href="group__BUFFER__API.html#ga2c9c14f8b8dc4a6cb6c137f533d8d14a">PIN_AllocateBuffer</a>, but this is only needed by tools using "double buffering".</p>
<p>Upon exit, the notification callback may be called on a different physical thread than the one that is exiting.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recordSize</td><td>Size (bytes) of each record in the buffer. This size must be less than the size of an OS page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numPages</td><td>The number of OS pages to allocate for each buffer. This size does not have to be an even multiple of <em>recordSize</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fun</td><td>A call-back function that is called whenever the buffer is full, or when the thread exits with a partially-full buffer. Note that when called for a full buffer, not during thread exit, this function is called WITHOUT holding any Pin locks. So that multiple threads may be executing the function simultaneously. It is the tool's responsibility to take care of the multi-thread safety of this function, and any functions called by it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Passed as the last argument to <em>fun</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success, a BUFFER_ID. On error (e.g., maximum number of trace buffers exceeded,) returns BUFFER_ID_INVALID.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux &amp; Windows<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c67a48c18fcdc9c88ed826e28f40434"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_GetBufferPointer" ref="ga2c67a48c18fcdc9c88ed826e28f40434" args="(CONTEXT *const ctxt, BUFFER_ID id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* LEVEL_PINCLIENT::PIN_GetBufferPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *const&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BUFFER_ID&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the address of the current position in the buffer. Needs a CONTEXT that was passed in as a call back argument or IARG_CONTEXT</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The ID of the trace buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>CONTEXT</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux &amp; Windows<br/>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br/>
 </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 5 2019 09:24:00 for Pin by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
