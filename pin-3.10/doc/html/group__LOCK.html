<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Pin: LOCK: Locking Primitives</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Pin</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">LOCK: Locking Primitives</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLEVEL__BASE_1_1PIN__LOCK.html">LEVEL_BASE::PIN_LOCK</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef PINVM::PINSYNC_POD_LOCK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga973e1a7aa00c2222b78a2d929942aa26">LEVEL_BASE::PIN_MUTEX</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef PINVM::PINSYNC_POD_RWLOCK&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga1a83b34b05b377bfe003e5dc6b3bd538">LEVEL_BASE::PIN_RWMUTEX</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
PINVM::PINSYNC_POD_SEMAPHORE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gacb5ef8f4cc82a8c52b76d4b36833efc9">LEVEL_BASE::PIN_SEMAPHORE</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gac9a323f8cf8f4ea4a12080f4b4099edc">LEVEL_BASE::PIN_InitLock</a> (PIN_LOCK *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga9569245cd781216f8f1a54d3a0962ddf">LEVEL_BASE::PIN_GetLock</a> (PIN_LOCK *lock, INT32 val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga00a837236be573c0c548191e0846df1d">LEVEL_BASE::PIN_ReleaseLock</a> (PIN_LOCK *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga3eac779ad4b2b25354c32e38e686bc23">LEVEL_BASE::PIN_MutexInit</a> (PIN_MUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga1ca0f0677773ec5226046f7080c7b80a">LEVEL_BASE::PIN_MutexFini</a> (PIN_MUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga06e1dcf8be9ec221b3a33a088442a258">LEVEL_BASE::PIN_MutexLock</a> (PIN_MUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gad4064bee5097081f70bcffada288ad64">LEVEL_BASE::PIN_MutexUnlock</a> (PIN_MUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga63a86610b3fcfe706d9f9b4b994edc8f">LEVEL_BASE::PIN_MutexTryLock</a> (PIN_MUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga5b92967aad8917bdc98073d49e1caf05">LEVEL_BASE::PIN_RWMutexInit</a> (PIN_RWMUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga6249bae3e5c0c5e3307c8dde2900f027">LEVEL_BASE::PIN_RWMutexFini</a> (PIN_RWMUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gafff39c1f90566f685e830e11683d7c43">LEVEL_BASE::PIN_RWMutexReadLock</a> (PIN_RWMUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gafb7a7e751583ee713fd347947cfeb9ea">LEVEL_BASE::PIN_RWMutexWriteLock</a> (PIN_RWMUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga6bf81704640b5afcfcd8e453d2b3cdcb">LEVEL_BASE::PIN_RWMutexUnlock</a> (PIN_RWMUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gac1b85d26ca88af1f08001fd9ce165ad8">LEVEL_BASE::PIN_RWMutexTryReadLock</a> (PIN_RWMUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gae23e9dac1682bb5619fc17aab2d9f559">LEVEL_BASE::PIN_RWMutexTryWriteLock</a> (PIN_RWMUTEX *lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga97c7eb94b7760217207942ff8543e564">LEVEL_BASE::PIN_SemaphoreInit</a> (PIN_SEMAPHORE *sem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga3412764276afe79a4d1c1df35b002072">LEVEL_BASE::PIN_SemaphoreFini</a> (PIN_SEMAPHORE *sem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga163634b37634a6361cff1dda18dc44a2">LEVEL_BASE::PIN_SemaphoreSet</a> (PIN_SEMAPHORE *sem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gab3ed7bfbf6350e0b3465d09965964d00">LEVEL_BASE::PIN_SemaphoreClear</a> (PIN_SEMAPHORE *sem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga2c63e8b3caf64837802c393277f3cd2d">LEVEL_BASE::PIN_SemaphoreIsSet</a> (PIN_SEMAPHORE *sem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#gaa15d7ac33e2f14bce0540d31ba7247fe">LEVEL_BASE::PIN_SemaphoreWait</a> (PIN_SEMAPHORE *sem)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LOCK.html#ga091e4cf3a2aa0b07e811bd7ade613b6a">LEVEL_BASE::PIN_SemaphoreTimedWait</a> (PIN_SEMAPHORE *sem, unsigned timeout)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Primitives for locking.<br/>
 APIs from this group are available in any thread, including any internal thread spawned by the tool.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br/>
 <b>O/S</b>: Linux &amp; Windows<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga973e1a7aa00c2222b78a2d929942aa26"></a><!-- doxytag: member="LEVEL_BASE::PIN_MUTEX" ref="ga973e1a7aa00c2222b78a2d929942aa26" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PINVM::PINSYNC_POD_LOCK <a class="el" href="group__LOCK.html#ga973e1a7aa00c2222b78a2d929942aa26">LEVEL_BASE::PIN_MUTEX</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A simple non-recursive lock. PIN_MUTEX is different from <a class="el" href="structLEVEL__BASE_1_1PIN__LOCK.html">PIN_LOCK</a> because it provides just mutex locking without an extra "lock owner" parameter.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For performance reasons this type request through compiler attributes to be aligned to a memory cache line (64 bytes). For statically allocated objects of this type it is enough. However, when allocating it dynamically it is advised to use allocation operation that enforces this alignment (e.g., memalign) </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a83b34b05b377bfe003e5dc6b3bd538"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMUTEX" ref="ga1a83b34b05b377bfe003e5dc6b3bd538" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PINVM::PINSYNC_POD_RWLOCK <a class="el" href="group__LOCK.html#ga1a83b34b05b377bfe003e5dc6b3bd538">LEVEL_BASE::PIN_RWMUTEX</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A non-recursive multiple-reader / single-writer lock. Use this lock when multiple "reader" threads can simultaneously access a shared resource, but "writer" threads need to have exclusive access. This is a write-biased lock: if a writer thread blocks on the lock because there are active readers, new readers are prevented from acquiring the lock until the writer gets access. This prevents starvation of writer threads.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For performance reasons this type request through compiler attributes to be aligned to a memory cache line (64 bytes). For statically allocated objects of this type it is enough. However, when allocating it dynamically it is advised to use allocation operation that enforces this alignment (e.g., memalign) </dd></dl>

</div>
</div>
<a class="anchor" id="gacb5ef8f4cc82a8c52b76d4b36833efc9"></a><!-- doxytag: member="LEVEL_BASE::PIN_SEMAPHORE" ref="gacb5ef8f4cc82a8c52b76d4b36833efc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PINVM::PINSYNC_POD_SEMAPHORE <a class="el" href="group__LOCK.html#gacb5ef8f4cc82a8c52b76d4b36833efc9">LEVEL_BASE::PIN_SEMAPHORE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A binary semaphore synchronization object. You can use this synchronization when one thread needs to wait for some condition to become true. A binary semaphore has exactly two states: "set" and "clear". It is possible for one or more threads to wait for the semaphore to become "set". Those threads resume when some other thread changes the state to "set".</p>
<p>Note that it is generally not safe to wait on a PIN_SEMAPHORE from an analysis routine or from a call-back function. Most Pin call-back functions are called while Pin holds an internal lock (the VM lock). Therefore, if you wait on a PIN_SEMAPHORE from a call-back, you will prevent any other thread from entering any call-back function (because the waiting thread also holds the VM lock). There is also a danger when waiting on a PIN_SEMAPHORE from an analysis routine. If a thread waits on a semaphore from an analysis routine, the application may also hold some locks of its own. Thus, you can cause a deadlock in the application if you wait on a semaphore while the application holds its own lock.</p>
<p>The dangers listed above do not exist if you wait on a PIN_SEMAPHORE from a Pin internal thread (see <a class="el" href="group__PIN__THREAD__API.html#gae5a4c5a6aa259ee6d89e856d5060b1f8">PIN_SpawnInternalThread()</a>). Also, it is safe to set, clear, or test a semaphore from any thread, even when executing an analysis routine or call-back function.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>For performance reasons this type request through compiler attributes to be aligned to a memory cache line (64 bytes). For statically allocated objects of this type it is enough. However, when allocating it dynamically it is advised to use allocation operation that enforces this alignment (e.g., memalign) </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga9569245cd781216f8f1a54d3a0962ddf"></a><!-- doxytag: member="LEVEL_BASE::PIN_GetLock" ref="ga9569245cd781216f8f1a54d3a0962ddf" args="(PIN_LOCK *lock, INT32 val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_GetLock </td>
          <td>(</td>
          <td class="paramtype">PIN_LOCK *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire the lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Used for debugging. Typically, this is the ID of the calling thread. See the <em>_owner</em> field of <a class="el" href="structLEVEL__BASE_1_1PIN__LOCK.html">PIN_LOCK</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac9a323f8cf8f4ea4a12080f4b4099edc"></a><!-- doxytag: member="LEVEL_BASE::PIN_InitLock" ref="gac9a323f8cf8f4ea4a12080f4b4099edc" args="(PIN_LOCK *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_InitLock </td>
          <td>(</td>
          <td class="paramtype">PIN_LOCK *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the lock as free</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1ca0f0677773ec5226046f7080c7b80a"></a><!-- doxytag: member="LEVEL_BASE::PIN_MutexFini" ref="ga1ca0f0677773ec5226046f7080c7b80a" args="(PIN_MUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_MutexFini </td>
          <td>(</td>
          <td class="paramtype">PIN_MUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the PIN_MUTEX and deallocate resources. If you want to use the lock object again later, you must call <a class="el" href="group__LOCK.html#ga3eac779ad4b2b25354c32e38e686bc23">PIN_MutexInit()</a> again.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3eac779ad4b2b25354c32e38e686bc23"></a><!-- doxytag: member="LEVEL_BASE::PIN_MutexInit" ref="ga3eac779ad4b2b25354c32e38e686bc23" args="(PIN_MUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_MutexInit </td>
          <td>(</td>
          <td class="paramtype">PIN_MUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function must be called to initialize a PIN_MUTEX before it is used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on successful initialization. If FALSE is returned, initialization failed, and the PIN_MUTEX may not be used. </dd></dl>

</div>
</div>
<a class="anchor" id="ga06e1dcf8be9ec221b3a33a088442a258"></a><!-- doxytag: member="LEVEL_BASE::PIN_MutexLock" ref="ga06e1dcf8be9ec221b3a33a088442a258" args="(PIN_MUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_MutexLock </td>
          <td>(</td>
          <td class="paramtype">PIN_MUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Block the caller until the lock can be acquired.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63a86610b3fcfe706d9f9b4b994edc8f"></a><!-- doxytag: member="LEVEL_BASE::PIN_MutexTryLock" ref="ga63a86610b3fcfe706d9f9b4b994edc8f" args="(PIN_MUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_MutexTryLock </td>
          <td>(</td>
          <td class="paramtype">PIN_MUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Try to acquire the lock, but do not block the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the lock is acquired, FALSE if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4064bee5097081f70bcffada288ad64"></a><!-- doxytag: member="LEVEL_BASE::PIN_MutexUnlock" ref="gad4064bee5097081f70bcffada288ad64" args="(PIN_MUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_MutexUnlock </td>
          <td>(</td>
          <td class="paramtype">PIN_MUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00a837236be573c0c548191e0846df1d"></a><!-- doxytag: member="LEVEL_BASE::PIN_ReleaseLock" ref="ga00a837236be573c0c548191e0846df1d" args="(PIN_LOCK *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 LEVEL_BASE::PIN_ReleaseLock </td>
          <td>(</td>
          <td class="paramtype">PIN_LOCK *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <em>val</em> parameter that was passed to <a class="el" href="group__LOCK.html#ga9569245cd781216f8f1a54d3a0962ddf">PIN_GetLock()</a> when the lock was acquired. Typically, this is the ID of the thread that owned the lock. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6249bae3e5c0c5e3307c8dde2900f027"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexFini" ref="ga6249bae3e5c0c5e3307c8dde2900f027" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_RWMutexFini </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the PIN_RWMUTEX and deallocate resources. If you want to use the lock object again later, you must call <a class="el" href="group__LOCK.html#ga5b92967aad8917bdc98073d49e1caf05">PIN_RWMutexInit()</a> again.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b92967aad8917bdc98073d49e1caf05"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexInit" ref="ga5b92967aad8917bdc98073d49e1caf05" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_RWMutexInit </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function must be called to initialize a PIN_RWMUTEX before it is used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on successful initialization. If FALSE is returned, initialization failed, and the PIN_RWMUTEX may not be used. </dd></dl>

</div>
</div>
<a class="anchor" id="gafff39c1f90566f685e830e11683d7c43"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexReadLock" ref="gafff39c1f90566f685e830e11683d7c43" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_RWMutexReadLock </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire the lock for "read" access, blocking if necessary. Multiple readers may simultaneously hold the same lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac1b85d26ca88af1f08001fd9ce165ad8"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexTryReadLock" ref="gac1b85d26ca88af1f08001fd9ce165ad8" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_RWMutexTryReadLock </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempts to acquire the lock as a reader, but does not block the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the lock is acquired, FALSE if not. </dd></dl>

</div>
</div>
<a class="anchor" id="gae23e9dac1682bb5619fc17aab2d9f559"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexTryWriteLock" ref="gae23e9dac1682bb5619fc17aab2d9f559" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_RWMutexTryWriteLock </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempts to acquire the lock as a writer, but does not block the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the lock is acquired, FALSE if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6bf81704640b5afcfcd8e453d2b3cdcb"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexUnlock" ref="ga6bf81704640b5afcfcd8e453d2b3cdcb" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_RWMutexUnlock </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the lock. Used for both "readers" and "writers".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafb7a7e751583ee713fd347947cfeb9ea"></a><!-- doxytag: member="LEVEL_BASE::PIN_RWMutexWriteLock" ref="gafb7a7e751583ee713fd347947cfeb9ea" args="(PIN_RWMUTEX *lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_RWMutexWriteLock </td>
          <td>(</td>
          <td class="paramtype">PIN_RWMUTEX *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire the lock for "write" access, blocking if necessary. A writer has exclusive ownership of the lock, not shared with any other readers or writers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab3ed7bfbf6350e0b3465d09965964d00"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreClear" ref="gab3ed7bfbf6350e0b3465d09965964d00" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_SemaphoreClear </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the semaphore's state to "clear". This has no effect on any threads waiting on the semaphore.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sem</td><td>The semaphore variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3412764276afe79a4d1c1df35b002072"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreFini" ref="ga3412764276afe79a4d1c1df35b002072" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_SemaphoreFini </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the PIN_SEMAPHORE and deallocate resources. If you want to use the lock object again later, you must call <a class="el" href="group__LOCK.html#ga97c7eb94b7760217207942ff8543e564">PIN_SemaphoreInit()</a> again.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sem</td><td>The semaphore variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga97c7eb94b7760217207942ff8543e564"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreInit" ref="ga97c7eb94b7760217207942ff8543e564" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_SemaphoreInit </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function must be called to initialize a PIN_SEMAPHORE before it is used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sem</td><td>The semaphore variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on successful initialization. If FALSE is returned, initialization failed, and the PIN_SEMAPHORE may not be used. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c63e8b3caf64837802c393277f3cd2d"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreIsSet" ref="ga2c63e8b3caf64837802c393277f3cd2d" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_SemaphoreIsSet </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check whether the semaphore's state is "set", but do not block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sem</td><td>The semaphore variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the semaphore's state is "set". </dd></dl>

</div>
</div>
<a class="anchor" id="ga163634b37634a6361cff1dda18dc44a2"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreSet" ref="ga163634b37634a6361cff1dda18dc44a2" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_SemaphoreSet </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the semaphore's state to "set" and tell any threads waiting on the semaphore to wake up. Note that threads waiting on the semaphore may not resume running right away, and they are guaranteed to resume only if the semaphore's state is still "set" when they actually do resume.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sem</td><td>The semaphore variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga091e4cf3a2aa0b07e811bd7ade613b6a"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreTimedWait" ref="ga091e4cf3a2aa0b07e811bd7ade613b6a" args="(PIN_SEMAPHORE *sem, unsigned timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_BASE::PIN_SemaphoreTimedWait </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Block the calling thread until the semaphore's state is "set" or until a timeout expires. The calling thread resumes immediately if the state is already "set".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sem</td><td>The semaphore variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The timeout period (milliseconds).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the semaphore's state is "set", FALSE if this method returns due to the timeout. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa15d7ac33e2f14bce0540d31ba7247fe"></a><!-- doxytag: member="LEVEL_BASE::PIN_SemaphoreWait" ref="gaa15d7ac33e2f14bce0540d31ba7247fe" args="(PIN_SEMAPHORE *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_BASE::PIN_SemaphoreWait </td>
          <td>(</td>
          <td class="paramtype">PIN_SEMAPHORE *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Block the calling thread until the semaphore's state is "set". The calling thread resumes immediately if the state is already "set".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sem</td><td>The semaphore variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 5 2019 09:24:00 for Pin by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
