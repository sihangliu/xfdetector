<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PinCRT: Memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PinCRT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory</div>  </div>
</div>
<div class="contents">

<p>Contains memory related os apis.  
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOS__MEMORY__AT__ADDR__INFORMATION.html">OS_MEMORY_AT_ADDR_INFORMATION</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OS__APIS__MEMORY.html#ga8b1f83ef2e6ff5fd685c9beb6249fbec">OS_PAGE_PROTECTION_TYPE</a> { <br/>
&#160;&#160;<b>OS_PAGE_PROTECTION_TYPE_NOACCESS</b> =  0, 
<br/>
&#160;&#160;<b>OS_PAGE_PROTECTION_TYPE_READ</b> =  (1&lt;&lt;0), 
<br/>
&#160;&#160;<b>OS_PAGE_PROTECTION_TYPE_WRITE</b> =  (1&lt;&lt;1), 
<br/>
&#160;&#160;<b>OS_PAGE_PROTECTION_TYPE_EXECUTE</b> =  (1&lt;&lt;2), 
<br/>
&#160;&#160;<b>OS_PAGE_PROTECTION_TYPE_GUARD</b> =  (1&lt;&lt;3)
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OS__APIS__MEMORY.html#gac040a9da8f2a5ffbefe23e96a14b97f3">OS_MEMORY_FLAGS</a> { <br/>
&#160;&#160;<a class="el" href="group__OS__APIS__MEMORY.html#ggac040a9da8f2a5ffbefe23e96a14b97f3ae03e654a5ec0b7b46ce676a877ae9a58">OS_MEMORY_FLAGS_PRIVATE</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="group__OS__APIS__MEMORY.html#ggac040a9da8f2a5ffbefe23e96a14b97f3ae650122f14758006ab0d3566e3b50eb6">OS_MEMORY_FLAGS_FIXED_ADDRESS</a> =  (1&lt;&lt;0), 
<br/>
&#160;&#160;<a class="el" href="group__OS__APIS__MEMORY.html#ggac040a9da8f2a5ffbefe23e96a14b97f3a911ef878523ce89b1ff21f883b66a251">OS_MEMORY_FLAGS_STACK</a> =  (1&lt;&lt;1), 
<br/>
&#160;&#160;<a class="el" href="group__OS__APIS__MEMORY.html#ggac040a9da8f2a5ffbefe23e96a14b97f3a94c6b592e34b15103e0b48f4563d89c7">OS_MEMORY_FLAGS_SHARED</a> =  (1&lt;&lt;3)
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OS__APIS__MEMORY.html#ga292fe0be7839ed9cc970254d288bb199">OS_AllocateMemory</a> (<a class="el" href="group__OS__APIS__TYPES.html#gae6c37d3a178129452bbb6e591c13aeb0">NATIVE_PID</a> processId, UINT protectionType, USIZE size, <a class="el" href="group__OS__APIS__MEMORY.html#gac040a9da8f2a5ffbefe23e96a14b97f3">OS_MEMORY_FLAGS</a> flags, VOID **base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OS__APIS__MEMORY.html#ga8e79ecf1778b1d8e8488f15a28b1caea">OS_MapFileToMemory</a> (<a class="el" href="group__OS__APIS__TYPES.html#gae6c37d3a178129452bbb6e591c13aeb0">NATIVE_PID</a> processId, UINT protectionType, USIZE size, <a class="el" href="group__OS__APIS__MEMORY.html#gac040a9da8f2a5ffbefe23e96a14b97f3">OS_MEMORY_FLAGS</a> flags, <a class="el" href="group__OS__APIS__TYPES.html#gaeb77513b3223d163064c7b1f5e38e8c3">NATIVE_FD</a> fd, UINT64 offset, VOID **base)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OS__APIS__MEMORY.html#gaa54a94130bdeef23bf5e9b4666e6c430">OS_FreeMemory</a> (<a class="el" href="group__OS__APIS__TYPES.html#gae6c37d3a178129452bbb6e591c13aeb0">NATIVE_PID</a> processId, VOID *base, USIZE size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OS__APIS__MEMORY.html#gaa76c49aabf3c8fdbfca2bf7a1d52a15e">OS_GetPageSize</a> (USIZE *size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OS__APIS__MEMORY.html#ga66948315f215e7db3099719f7c81df3d">OS_QueryMemory</a> (<a class="el" href="group__OS__APIS__TYPES.html#gae6c37d3a178129452bbb6e591c13aeb0">NATIVE_PID</a> processId, VOID *memoryAddr, <a class="el" href="structOS__MEMORY__AT__ADDR__INFORMATION.html">OS_MEMORY_AT_ADDR_INFORMATION</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__OS__APIS__MEMORY.html#ga735acbcf7139e9d3a45988005a98854d">OS_ProtectMemory</a> (<a class="el" href="group__OS__APIS__TYPES.html#gae6c37d3a178129452bbb6e591c13aeb0">NATIVE_PID</a> processId, VOID *base, USIZE size, UINT newProtectionType)</td></tr>
</table>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gac040a9da8f2a5ffbefe23e96a14b97f3"></a><!-- doxytag: member="memory.h::OS_MEMORY_FLAGS" ref="gac040a9da8f2a5ffbefe23e96a14b97f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__OS__APIS__MEMORY.html#gac040a9da8f2a5ffbefe23e96a14b97f3">OS_MEMORY_FLAGS</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flags for memory mapping. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggac040a9da8f2a5ffbefe23e96a14b97f3ae03e654a5ec0b7b46ce676a877ae9a58"></a><!-- doxytag: member="OS_MEMORY_FLAGS_PRIVATE" ref="ggac040a9da8f2a5ffbefe23e96a14b97f3ae03e654a5ec0b7b46ce676a877ae9a58" args="" -->OS_MEMORY_FLAGS_PRIVATE</em>&nbsp;</td><td>
<p>The memory should be private to the process. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac040a9da8f2a5ffbefe23e96a14b97f3ae650122f14758006ab0d3566e3b50eb6"></a><!-- doxytag: member="OS_MEMORY_FLAGS_FIXED_ADDRESS" ref="ggac040a9da8f2a5ffbefe23e96a14b97f3ae650122f14758006ab0d3566e3b50eb6" args="" -->OS_MEMORY_FLAGS_FIXED_ADDRESS</em>&nbsp;</td><td>
<p>The memory should be mapped exactly at the specified address. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac040a9da8f2a5ffbefe23e96a14b97f3a911ef878523ce89b1ff21f883b66a251"></a><!-- doxytag: member="OS_MEMORY_FLAGS_STACK" ref="ggac040a9da8f2a5ffbefe23e96a14b97f3a911ef878523ce89b1ff21f883b66a251" args="" -->OS_MEMORY_FLAGS_STACK</em>&nbsp;</td><td>
<p>The memory should be mapped as stack (grows down). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggac040a9da8f2a5ffbefe23e96a14b97f3a94c6b592e34b15103e0b48f4563d89c7"></a><!-- doxytag: member="OS_MEMORY_FLAGS_SHARED" ref="ggac040a9da8f2a5ffbefe23e96a14b97f3a94c6b592e34b15103e0b48f4563d89c7" args="" -->OS_MEMORY_FLAGS_SHARED</em>&nbsp;</td><td>
<p>The memory might be shared among processes. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8b1f83ef2e6ff5fd685c9beb6249fbec"></a><!-- doxytag: member="memory.h::OS_PAGE_PROTECTION_TYPE" ref="ga8b1f83ef2e6ff5fd685c9beb6249fbec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__OS__APIS__MEMORY.html#ga8b1f83ef2e6ff5fd685c9beb6249fbec">OS_PAGE_PROTECTION_TYPE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Page protection types </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga292fe0be7839ed9cc970254d288bb199"></a><!-- doxytag: member="memory.h::OS_AllocateMemory" ref="ga292fe0be7839ed9cc970254d288bb199" args="(NATIVE_PID processId, UINT protectionType, USIZE size, OS_MEMORY_FLAGS flags, VOID **base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a> OS_AllocateMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__OS__APIS__TYPES.html#gae6c37d3a178129452bbb6e591c13aeb0">NATIVE_PID</a>&#160;</td>
          <td class="paramname"><em>processId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>protectionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USIZE&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__OS__APIS__MEMORY.html#gac040a9da8f2a5ffbefe23e96a14b97f3">OS_MEMORY_FLAGS</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID **&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates <b>size</b> bytes of memory in the process identified by <b>processId</b> with <a class="el" href="group__OS__APIS__MEMORY.html#ga8b1f83ef2e6ff5fd685c9beb6249fbec"><b>protectionType</b> protection</a>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If <b>base</b> is not null, will try to allocate at that address, otherwise will fail!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">processId</td><td>PID of the target process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protectionType</td><td>or'ed <a class="el" href="group__OS__APIS__MEMORY.html#ga8b1f83ef2e6ff5fd685c9beb6249fbec">protection options</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of memory to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Properties of the region to allocate. This is a bitwise OR of the enum values in OS_MEMORY_FLAGS. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">base</td><td>in: Target memory address<br/>
 out: Where the memory was allocated</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">OS_RETURN_CODE_NO_ERROR</td><td>If the operation succeeded </td></tr>
    <tr><td class="paramname">OS_RETURN_CODE_MEMORY_MAP_FAILED</td><td>If the operation Failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><b>Unix:</b> <br/>
 The processId is irrelevant as it is only applicable on the current process.<br/>
 On Unix system, memory can only be allocated for the calling process.<br/>
 The given pid is expected to be that of the current process. Hence the behavior of this function in case 'processId' is not of the current process is not defined. <b>Windows:</b> <br/>
 Windows supports memory allocation on a different process on a single syscall.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>O/S</b>: Windows, Linux &amp; macOS*<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa54a94130bdeef23bf5e9b4666e6c430"></a><!-- doxytag: member="memory.h::OS_FreeMemory" ref="gaa54a94130bdeef23bf5e9b4666e6c430" args="(NATIVE_PID processId, VOID *base, USIZE size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a> OS_FreeMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__OS__APIS__TYPES.html#gae6c37d3a178129452bbb6e591c13aeb0">NATIVE_PID</a>&#160;</td>
          <td class="paramname"><em>processId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USIZE&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free's <b>size</b> bytes of memory at <b>base</b> address in the process identified by <b>processId</b>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">processId</td><td>PID of the target process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>Target memory address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of memory to free</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">OS_RETURN_CODE_NO_ERROR</td><td>If the operation succeeded </td></tr>
    <tr><td class="paramname">OS_RETURN_CODE_MEMORY_FREE_FAILED</td><td>If the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><b>Unix:</b> <br/>
 The processId is irrelevant as it is only applicable on the current process. <br/>
 On Unix system, memory can only be released in the current process.<br/>
 The given pid is expected to be that of the current process. Hence the behavior of this function in case 'processId' is not of the current process is not defined. <b>Windows:</b> <br/>
 Windows supports memory deallocation on a different process.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>O/S</b>: Windows, Linux &amp; macOS* <br/>
 <b>CPU:</b> All <br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gaa76c49aabf3c8fdbfca2bf7a1d52a15e"></a><!-- doxytag: member="memory.h::OS_GetPageSize" ref="gaa76c49aabf3c8fdbfca2bf7a1d52a15e" args="(USIZE *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a> OS_GetPageSize </td>
          <td>(</td>
          <td class="paramtype">USIZE *&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Query the system page size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>System page size</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">OS_RETURN_CODE_NO_ERROR</td><td>If the operation succeeded </td></tr>
    <tr><td class="paramname">OS_RETURN_CODE_QUERY_FAILED</td><td>If the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>O/S</b>: Windows, Linux &amp; macOS* <br/>
 <b>CPU:</b> All <br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e79ecf1778b1d8e8488f15a28b1caea"></a><!-- doxytag: member="memory.h::OS_MapFileToMemory" ref="ga8e79ecf1778b1d8e8488f15a28b1caea" args="(NATIVE_PID processId, UINT protectionType, USIZE size, OS_MEMORY_FLAGS flags, NATIVE_FD fd, UINT64 offset, VOID **base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a> OS_MapFileToMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__OS__APIS__TYPES.html#gae6c37d3a178129452bbb6e591c13aeb0">NATIVE_PID</a>&#160;</td>
          <td class="paramname"><em>processId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>protectionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USIZE&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__OS__APIS__MEMORY.html#gac040a9da8f2a5ffbefe23e96a14b97f3">OS_MEMORY_FLAGS</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__OS__APIS__TYPES.html#gaeb77513b3223d163064c7b1f5e38e8c3">NATIVE_FD</a>&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID **&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maps a file into memory, similar to mmap (see man page of mmap(2)).</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If <b>base</b> is not null, will try to allocate at that address, otherwise will fail!</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">processId</td><td>PID of the target process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">protectionType</td><td>or'ed <a class="el" href="group__OS__APIS__MEMORY.html#ga8b1f83ef2e6ff5fd685c9beb6249fbec">protection options</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of memory to allocate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Properties of the region to allocate. This is a bitwise OR of the enum values in OS_MEMORY_FLAGS. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor of the file that we want to map to memory. This argument can be INVALID_NATIVE_FD if one wants to map an anonymous file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Bytes offset in the file to start mapping from. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">base</td><td>in: Target memory address<br/>
 out: Where the memory was allocated</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">OS_RETURN_CODE_NO_ERROR</td><td>If the operation succeeded </td></tr>
    <tr><td class="paramname">OS_RETURN_CODE_MEMORY_MAP_FAILED</td><td>If the operation Failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><b>Unix:</b> <br/>
 The processId is irrelevant as it is only applicable on the current process.<br/>
 On Unix system, files can be mapped only in the calling process memory space.<br/>
 The given pid is expected to be that of the current process.<br/>
 Hence the behavior of this function in case 'processId' is not of the current process is not defined. <b>Windows:</b> <br/>
 Windows supports file mapping on a different process memory space.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>O/S</b>: Windows, Linux &amp; macOS*<br/>
 <b>CPU:</b> All<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ga735acbcf7139e9d3a45988005a98854d"></a><!-- doxytag: member="memory.h::OS_ProtectMemory" ref="ga735acbcf7139e9d3a45988005a98854d" args="(NATIVE_PID processId, VOID *base, USIZE size, UINT newProtectionType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a> OS_ProtectMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__OS__APIS__TYPES.html#gae6c37d3a178129452bbb6e591c13aeb0">NATIVE_PID</a>&#160;</td>
          <td class="paramname"><em>processId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USIZE&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>newProtectionType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Changes protection for the target process's memory page(s) containing any part of the address range in the interval [base, base+size-1]. base must be aligned to a page boundary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">processId</td><td>PID of the target process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The address of the starting page - must be page aligned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of the region to change protection - must be multiple of page size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newProtectionType</td><td>The new protection mode</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">OS_RETURN_CODE_NO_ERROR</td><td>If the operation succeeded </td></tr>
    <tr><td class="paramname">OS_RETURN_CODE_MEMORY_PROTECT_FAILED</td><td>If the operation failed</td></tr>
  </table>
  </dd>
</dl>
<p><b>Unix:</b> <br/>
 The processId is irrelevant as it is only applicable on the current process. <br/>
 On Unix system, memory protection can only be changed for the current process' memory space.<br/>
 The given pid is expected to be that of the current process. Hence the behavior of this function in case 'processId' is not of the current process is not defined. <b>Windows:</b> <br/>
 Windows supports memory protection change on a different process memory space.</p>
<dl class="user"><dt><b>Availability:</b></dt><dd><ul>
<li><b>O/S</b>: Windows, Linux &amp; macOS*</li>
<li><b>CPU:</b> All </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga66948315f215e7db3099719f7c81df3d"></a><!-- doxytag: member="memory.h::OS_QueryMemory" ref="ga66948315f215e7db3099719f7c81df3d" args="(NATIVE_PID processId, VOID *memoryAddr, OS_MEMORY_AT_ADDR_INFORMATION *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__OS__RETURN__CODE.html">OS_RETURN_CODE</a> OS_QueryMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__OS__APIS__TYPES.html#gae6c37d3a178129452bbb6e591c13aeb0">NATIVE_PID</a>&#160;</td>
          <td class="paramname"><em>processId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>memoryAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOS__MEMORY__AT__ADDR__INFORMATION.html">OS_MEMORY_AT_ADDR_INFORMATION</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the information on the memory block containing <b>memoryAddr</b>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">processId</td><td>PID of the target process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memoryAddr</td><td>Target memory address. This memory address can reside inside the page. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>The address information On Unix, if there is no mapped memory block that contains <b>memoryAddr</b> the next mapped memory block will be returned. If no such mapped memory block exists, an empty memory block will be returned On Windows, we return the containing memory block regardless if it is mapped or not.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">OS_RETURN_CODE_NO_ERROR</td><td>If the operation succeeded </td></tr>
    <tr><td class="paramname">OS_RETURN_CODE_QUERY_FAILED</td><td>If the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd><b>Unix:</b> <br/>
 The processId is irrelevant as it is only applicable on the current process. <br/>
 On Unix system, memory can only be queried for the current process.<br/>
 The given pid is expected to be that of the current process. Hence the behavior of this function in case 'processId' is not of the current process is not defined.<br/>
 <b>Windows:</b> <br/>
 Windows supports memory query on a different process memory space.</dd></dl>
<dl class="user"><dt><b>Availability:</b></dt><dd><b>O/S</b>: Windows, Linux &amp; macOS* <br/>
 <b>CPU:</b> All <br/>
 </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 5 2019 09:25:08 for PinCRT by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
